 x402 Protokolü — Web-Native Ödeme Standartı

## 🎯 Giriş
**x402**, HTTP protokolündeki `402 Payment Required` durum kodunu aktif olarak kullanan, zincir-bağımsız (chain-agnostic) bir **açık ödeme standardıdır**.  
Amaç: İnternet üzerinde kaynaklara (API, veri, içerik, hizmet) **doğrudan ödeme yaparak erişim** sağlamaktır.  
→ Abonelik, OAuth, kayıt işlemleri olmadan “kullandığın kadar öde” modelini mümkün kılar.

---

## 🔗 Resmi Kaynaklar
- 🌐 [x402.org — Resmî site](https://www.x402.org)
- 💡 [Coinbase Developer Docs: x402 Core Concepts](https://docs.cdp.coinbase.com/x402/core-concepts/http-402)
- 💻 [GitHub — coinbase/x402 repository](https://github.com/coinbase/x402)
- 📚 [QuickNode Guide: How to use x402 Payment Required](https://www.quicknode.com/guides/infrastructure/how-to-use-x402-payment-required)
- 🧵 [Reddit — Teknik tartışma](https://www.reddit.com/r/CryptoTechnology/comments/1leki7h/x402_an_open_standard_for_internetnative_payments/)
- 📷 Görsel: Coinbase Developer Blog – *x402 protocol flow diagram*

---

## ⚙️ Temel Akış

1. **İstemci (Client)** bir web kaynağına istek gönderir.
2. **Sunucu (Resource Server)** bu kaynağın ücretli olduğunu fark eder ve:
   ```http
   HTTP/1.1 402 Payment Required
   Content-Type: application/json

   {
     "amount": "1",
     "currency": "USDC",
     "chain": "base",
     "payTo": "0xReceiverAddress",
     "reason": "Mint 10,000 MEME tokens"
   }
İstemci ödeme yapar ve isteği X-PAYMENT başlığıyla tekrar yollar.

Sunucu ödemeyi doğrular (ya kendi node’una ya da bir facilitator API’ye sorarak).

Onaylanırsa kaynak erişimi veya zincir üstü işlem (örneğin mint) gerçekleştirilir.

💰 Pay-to-Mint Senaryosu
Senaryon:

Kullanıcı 1 USDC öder → karşılığında 10 000 MEME token mintlenir.

Akış Şeması
pgsql
Kodu kopyala
Client → POST /mint
         ↓
Server → 402 Payment Required (x402 standardı)
         ↓
Client → X-PAYMENT header + ödeme
         ↓
Server → Mint işlemini tetikler
         ↓
User → 10 000 MEME token alır ✅
🧱 Kontrat Yapısı (Solidity)
solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract MemeToken is ERC20, Ownable {
    uint256 public constant TOKENS_PER_USDC = 10_000 * 10**18;
    address public trustedMinter;

    constructor() ERC20("Meme Token", "MEME") {}

    function setTrustedMinter(address _minter) external onlyOwner {
        trustedMinter = _minter;
    }

    function mintForUser(address user, uint256 usdcAmount) external {
        require(msg.sender == trustedMinter, "Not authorized");
        uint256 amountToMint = usdcAmount * TOKENS_PER_USDC / 1e6; // USDC 6 decimals
        _mint(user, amountToMint);
    }
}
